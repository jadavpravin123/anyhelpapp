{"ast":null,"code":"// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { HandshakeProtocol } from \"./HandshakeProtocol\";\nimport { MessageType } from \"./IHubProtocol\";\nimport { LogLevel } from \"./ILogger\";\nimport { Subject } from \"./Subject\";\nimport { Arg } from \"./Utils\";\nvar DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\nvar DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\n/** Describes the current state of the {@link HubConnection} to the server. */\n\nexport var HubConnectionState = /*@__PURE__*/function (HubConnectionState) {\n  /** The hub connection is disconnected. */\n  HubConnectionState[\"Disconnected\"] = \"Disconnected\";\n  /** The hub connection is connecting. */\n\n  HubConnectionState[\"Connecting\"] = \"Connecting\";\n  /** The hub connection is connected. */\n\n  HubConnectionState[\"Connected\"] = \"Connected\";\n  /** The hub connection is disconnecting. */\n\n  HubConnectionState[\"Disconnecting\"] = \"Disconnecting\";\n  /** The hub connection is reconnecting. */\n\n  HubConnectionState[\"Reconnecting\"] = \"Reconnecting\";\n  return HubConnectionState;\n}({});\n/** Represents a connection to a SignalR Hub. */\n\nvar HubConnection = function () {\n  function HubConnection(connection, logger, protocol, reconnectPolicy) {\n    var _this = this;\n\n    Arg.isRequired(connection, \"connection\");\n    Arg.isRequired(logger, \"logger\");\n    Arg.isRequired(protocol, \"protocol\");\n    this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\n    this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\n    this.logger = logger;\n    this.protocol = protocol;\n    this.connection = connection;\n    this.reconnectPolicy = reconnectPolicy;\n    this.handshakeProtocol = new HandshakeProtocol();\n\n    this.connection.onreceive = function (data) {\n      return _this.processIncomingData(data);\n    };\n\n    this.connection.onclose = function (error) {\n      return _this.connectionClosed(error);\n    };\n\n    this.callbacks = {};\n    this.methods = {};\n    this.closedCallbacks = [];\n    this.reconnectingCallbacks = [];\n    this.reconnectedCallbacks = [];\n    this.invocationId = 0;\n    this.receivedHandshakeResponse = false;\n    this.connectionState = HubConnectionState.Disconnected;\n    this.connectionStarted = false;\n    this.cachedPingMessage = this.protocol.writeMessage({\n      type: MessageType.Ping\n    });\n  }\n  /** @internal */\n  // Using a public static factory method means we can have a private constructor and an _internal_\n  // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\n  // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\n  // public parameter-less constructor.\n\n\n  HubConnection.create = function (connection, logger, protocol, reconnectPolicy) {\n    return new HubConnection(connection, logger, protocol, reconnectPolicy);\n  };\n\n  Object.defineProperty(HubConnection.prototype, \"state\", {\n    /** Indicates the state of the {@link HubConnection} to the server. */\n    get: function () {\n      return this.connectionState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HubConnection.prototype, \"connectionId\", {\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\n    get: function () {\n      return this.connection ? this.connection.connectionId || null : null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HubConnection.prototype, \"baseUrl\", {\n    /** Indicates the url of the {@link HubConnection} to the server. */\n    get: function () {\n      return this.connection.baseUrl || \"\";\n    },\n\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */\n    set: function (url) {\n      if (this.connectionState !== HubConnectionState.Disconnected && this.connectionState !== HubConnectionState.Reconnecting) {\n        throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\n      }\n\n      if (!url) {\n        throw new Error(\"The HubConnection url must be a valid url.\");\n      }\n\n      this.connection.baseUrl = url;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** Starts the connection.\r\n   *\r\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n   */\n\n  HubConnection.prototype.start = function () {\n    this.startPromise = this.startWithStateTransitions();\n    return this.startPromise;\n  };\n\n  HubConnection.prototype.startWithStateTransitions = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.connectionState !== HubConnectionState.Disconnected) {\n              return [2\n              /*return*/\n              , Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"))];\n            }\n\n            this.connectionState = HubConnectionState.Connecting;\n            this.logger.log(LogLevel.Debug, \"Starting HubConnection.\");\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.startInternal()];\n\n          case 2:\n            _a.sent();\n\n            this.connectionState = HubConnectionState.Connected;\n            this.connectionStarted = true;\n            this.logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_1 = _a.sent();\n            this.connectionState = HubConnectionState.Disconnected;\n            this.logger.log(LogLevel.Debug, \"HubConnection failed to start successfully because of error '\" + e_1 + \"'.\");\n            return [2\n            /*return*/\n            , Promise.reject(e_1)];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HubConnection.prototype.startInternal = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var handshakePromise, handshakeRequest, e_2;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.stopDuringStartError = undefined;\n            this.receivedHandshakeResponse = false;\n            handshakePromise = new Promise(function (resolve, reject) {\n              _this.handshakeResolver = resolve;\n              _this.handshakeRejecter = reject;\n            });\n            return [4\n            /*yield*/\n            , this.connection.start(this.protocol.transferFormat)];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 5,, 7]);\n\n            handshakeRequest = {\n              protocol: this.protocol.name,\n              version: this.protocol.version\n            };\n            this.logger.log(LogLevel.Debug, \"Sending handshake request.\");\n            return [4\n            /*yield*/\n            , this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];\n\n          case 3:\n            _a.sent();\n\n            this.logger.log(LogLevel.Information, \"Using HubProtocol '\" + this.protocol.name + \"'.\"); // defensively cleanup timeout in case we receive a message from the server before we finish start\n\n            this.cleanupTimeout();\n            this.resetTimeoutPeriod();\n            this.resetKeepAliveInterval();\n            return [4\n            /*yield*/\n            , handshakePromise];\n\n          case 4:\n            _a.sent(); // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\n            // being rejected on close, because this continuation can run after both the handshake completed successfully\n            // and the connection was closed.\n\n\n            if (this.stopDuringStartError) {\n              // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\n              // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\n              // will cause the calling continuation to get scheduled to run later.\n              throw this.stopDuringStartError;\n            }\n\n            return [3\n            /*break*/\n            , 7];\n\n          case 5:\n            e_2 = _a.sent();\n            this.logger.log(LogLevel.Debug, \"Hub handshake failed with error '\" + e_2 + \"' during start(). Stopping HubConnection.\");\n            this.cleanupTimeout();\n            this.cleanupPingTimer(); // HttpConnection.stop() should not complete until after the onclose callback is invoked.\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\n\n            return [4\n            /*yield*/\n            , this.connection.stop(e_2)];\n\n          case 6:\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\n            _a.sent();\n\n            throw e_2;\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /** Stops the connection.\r\n   *\r\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n   */\n\n\n  HubConnection.prototype.stop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var startPromise, e_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            startPromise = this.startPromise;\n            this.stopPromise = this.stopInternal();\n            return [4\n            /*yield*/\n            , this.stopPromise];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 4,, 5]); // Awaiting undefined continues immediately\n\n\n            return [4\n            /*yield*/\n            , startPromise];\n\n          case 3:\n            // Awaiting undefined continues immediately\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            e_3 = _a.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HubConnection.prototype.stopInternal = function (error) {\n    if (this.connectionState === HubConnectionState.Disconnected) {\n      this.logger.log(LogLevel.Debug, \"Call to HubConnection.stop(\" + error + \") ignored because it is already in the disconnected state.\");\n      return Promise.resolve();\n    }\n\n    if (this.connectionState === HubConnectionState.Disconnecting) {\n      this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnecting state.\");\n      return this.stopPromise;\n    }\n\n    this.connectionState = HubConnectionState.Disconnecting;\n    this.logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\n\n    if (this.reconnectDelayHandle) {\n      // We're in a reconnect delay which means the underlying connection is currently already stopped.\n      // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\n      // fire the onclose callbacks.\n      this.logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\n      clearTimeout(this.reconnectDelayHandle);\n      this.reconnectDelayHandle = undefined;\n      this.completeClose();\n      return Promise.resolve();\n    }\n\n    this.cleanupTimeout();\n    this.cleanupPingTimer();\n    this.stopDuringStartError = error || new Error(\"The connection was stopped before the hub handshake could complete.\"); // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\n    // or the onclose callback is invoked. The onclose callback will transition the HubConnection\n    // to the disconnected state if need be before HttpConnection.stop() completes.\n\n    return this.connection.stop(error);\n  };\n  /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n   *\r\n   * @typeparam T The type of the items returned by the server.\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n   */\n\n\n  HubConnection.prototype.stream = function (methodName) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var _a = this.replaceStreamingParams(args),\n        streams = _a[0],\n        streamIds = _a[1];\n\n    var invocationDescriptor = this.createStreamInvocation(methodName, args, streamIds);\n    var promiseQueue;\n    var subject = new Subject();\n\n    subject.cancelCallback = function () {\n      var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);\n\n      delete _this.callbacks[invocationDescriptor.invocationId];\n      return promiseQueue.then(function () {\n        return _this.sendWithProtocol(cancelInvocation);\n      });\n    };\n\n    this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n      if (error) {\n        subject.error(error);\n        return;\n      } else if (invocationEvent) {\n        // invocationEvent will not be null when an error is not passed to the callback\n        if (invocationEvent.type === MessageType.Completion) {\n          if (invocationEvent.error) {\n            subject.error(new Error(invocationEvent.error));\n          } else {\n            subject.complete();\n          }\n        } else {\n          subject.next(invocationEvent.item);\n        }\n      }\n    };\n\n    promiseQueue = this.sendWithProtocol(invocationDescriptor).catch(function (e) {\n      subject.error(e);\n      delete _this.callbacks[invocationDescriptor.invocationId];\n    });\n    this.launchStreams(streams, promiseQueue);\n    return subject;\n  };\n\n  HubConnection.prototype.sendMessage = function (message) {\n    this.resetKeepAliveInterval();\n    return this.connection.send(message);\n  };\n  /**\r\n   * Sends a js object to the server.\r\n   * @param message The js object to serialize and send.\r\n   */\n\n\n  HubConnection.prototype.sendWithProtocol = function (message) {\n    return this.sendMessage(this.protocol.writeMessage(message));\n  };\n  /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n   *\r\n   * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n   * be processing the invocation.\r\n   *\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n   */\n\n\n  HubConnection.prototype.send = function (methodName) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var _a = this.replaceStreamingParams(args),\n        streams = _a[0],\n        streamIds = _a[1];\n\n    var sendPromise = this.sendWithProtocol(this.createInvocation(methodName, args, true, streamIds));\n    this.launchStreams(streams, sendPromise);\n    return sendPromise;\n  };\n  /** Invokes a hub method on the server using the specified name and arguments.\r\n   *\r\n   * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n   * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n   * resolving the Promise.\r\n   *\r\n   * @typeparam T The expected return type.\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n   */\n\n\n  HubConnection.prototype.invoke = function (methodName) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var _a = this.replaceStreamingParams(args),\n        streams = _a[0],\n        streamIds = _a[1];\n\n    var invocationDescriptor = this.createInvocation(methodName, args, false, streamIds);\n    var p = new Promise(function (resolve, reject) {\n      // invocationId will always have a value for a non-blocking invocation\n      _this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n        if (error) {\n          reject(error);\n          return;\n        } else if (invocationEvent) {\n          // invocationEvent will not be null when an error is not passed to the callback\n          if (invocationEvent.type === MessageType.Completion) {\n            if (invocationEvent.error) {\n              reject(new Error(invocationEvent.error));\n            } else {\n              resolve(invocationEvent.result);\n            }\n          } else {\n            reject(new Error(\"Unexpected message type: \" + invocationEvent.type));\n          }\n        }\n      };\n\n      var promiseQueue = _this.sendWithProtocol(invocationDescriptor).catch(function (e) {\n        reject(e); // invocationId will always have a value for a non-blocking invocation\n\n        delete _this.callbacks[invocationDescriptor.invocationId];\n      });\n\n      _this.launchStreams(streams, promiseQueue);\n    });\n    return p;\n  };\n  /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n   *\r\n   * @param {string} methodName The name of the hub method to define.\r\n   * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n   */\n\n\n  HubConnection.prototype.on = function (methodName, newMethod) {\n    if (!methodName || !newMethod) {\n      return;\n    }\n\n    methodName = methodName.toLowerCase();\n\n    if (!this.methods[methodName]) {\n      this.methods[methodName] = [];\n    } // Preventing adding the same handler multiple times.\n\n\n    if (this.methods[methodName].indexOf(newMethod) !== -1) {\n      return;\n    }\n\n    this.methods[methodName].push(newMethod);\n  };\n\n  HubConnection.prototype.off = function (methodName, method) {\n    if (!methodName) {\n      return;\n    }\n\n    methodName = methodName.toLowerCase();\n    var handlers = this.methods[methodName];\n\n    if (!handlers) {\n      return;\n    }\n\n    if (method) {\n      var removeIdx = handlers.indexOf(method);\n\n      if (removeIdx !== -1) {\n        handlers.splice(removeIdx, 1);\n\n        if (handlers.length === 0) {\n          delete this.methods[methodName];\n        }\n      }\n    } else {\n      delete this.methods[methodName];\n    }\n  };\n  /** Registers a handler that will be invoked when the connection is closed.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n   */\n\n\n  HubConnection.prototype.onclose = function (callback) {\n    if (callback) {\n      this.closedCallbacks.push(callback);\n    }\n  };\n  /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n   */\n\n\n  HubConnection.prototype.onreconnecting = function (callback) {\n    if (callback) {\n      this.reconnectingCallbacks.push(callback);\n    }\n  };\n  /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n   */\n\n\n  HubConnection.prototype.onreconnected = function (callback) {\n    if (callback) {\n      this.reconnectedCallbacks.push(callback);\n    }\n  };\n\n  HubConnection.prototype.processIncomingData = function (data) {\n    this.cleanupTimeout();\n\n    if (!this.receivedHandshakeResponse) {\n      data = this.processHandshakeResponse(data);\n      this.receivedHandshakeResponse = true;\n    } // Data may have all been read when processing handshake response\n\n\n    if (data) {\n      // Parse the messages\n      var messages = this.protocol.parseMessages(data, this.logger);\n\n      for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {\n        var message = messages_1[_i];\n\n        switch (message.type) {\n          case MessageType.Invocation:\n            this.invokeClientMethod(message);\n            break;\n\n          case MessageType.StreamItem:\n          case MessageType.Completion:\n            var callback = this.callbacks[message.invocationId];\n\n            if (callback) {\n              if (message.type === MessageType.Completion) {\n                delete this.callbacks[message.invocationId];\n              }\n\n              callback(message);\n            }\n\n            break;\n\n          case MessageType.Ping:\n            // Don't care about pings\n            break;\n\n          case MessageType.Close:\n            this.logger.log(LogLevel.Information, \"Close message received from server.\");\n            var error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\n\n            if (message.allowReconnect === true) {\n              // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\n              // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\n              // tslint:disable-next-line:no-floating-promises\n              this.connection.stop(error);\n            } else {\n              // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\n              this.stopPromise = this.stopInternal(error);\n            }\n\n            break;\n\n          default:\n            this.logger.log(LogLevel.Warning, \"Invalid message type: \" + message.type + \".\");\n            break;\n        }\n      }\n    }\n\n    this.resetTimeoutPeriod();\n  };\n\n  HubConnection.prototype.processHandshakeResponse = function (data) {\n    var _a;\n\n    var responseMessage;\n    var remainingData;\n\n    try {\n      _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];\n    } catch (e) {\n      var message = \"Error parsing handshake response: \" + e;\n      this.logger.log(LogLevel.Error, message);\n      var error = new Error(message);\n      this.handshakeRejecter(error);\n      throw error;\n    }\n\n    if (responseMessage.error) {\n      var message = \"Server returned handshake error: \" + responseMessage.error;\n      this.logger.log(LogLevel.Error, message);\n      var error = new Error(message);\n      this.handshakeRejecter(error);\n      throw error;\n    } else {\n      this.logger.log(LogLevel.Debug, \"Server handshake complete.\");\n    }\n\n    this.handshakeResolver();\n    return remainingData;\n  };\n\n  HubConnection.prototype.resetKeepAliveInterval = function () {\n    var _this = this;\n\n    if (this.connection.features.inherentKeepAlive) {\n      return;\n    }\n\n    this.cleanupPingTimer();\n    this.pingServerHandle = setTimeout(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              if (!(this.connectionState === HubConnectionState.Connected)) return [3\n              /*break*/\n              , 4];\n              _b.label = 1;\n\n            case 1:\n              _b.trys.push([1, 3,, 4]);\n\n              return [4\n              /*yield*/\n              , this.sendMessage(this.cachedPingMessage)];\n\n            case 2:\n              _b.sent();\n\n              return [3\n              /*break*/\n              , 4];\n\n            case 3:\n              _a = _b.sent(); // We don't care about the error. It should be seen elsewhere in the client.\n              // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\n\n              this.cleanupPingTimer();\n              return [3\n              /*break*/\n              , 4];\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }, this.keepAliveIntervalInMilliseconds);\n  };\n\n  HubConnection.prototype.resetTimeoutPeriod = function () {\n    var _this = this;\n\n    if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\n      // Set the timeout timer\n      this.timeoutHandle = setTimeout(function () {\n        return _this.serverTimeout();\n      }, this.serverTimeoutInMilliseconds);\n    }\n  };\n\n  HubConnection.prototype.serverTimeout = function () {\n    // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\n    // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\n    // tslint:disable-next-line:no-floating-promises\n    this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\n  };\n\n  HubConnection.prototype.invokeClientMethod = function (invocationMessage) {\n    var _this = this;\n\n    var methods = this.methods[invocationMessage.target.toLowerCase()];\n\n    if (methods) {\n      try {\n        methods.forEach(function (m) {\n          return m.apply(_this, invocationMessage.arguments);\n        });\n      } catch (e) {\n        this.logger.log(LogLevel.Error, \"A callback for the method \" + invocationMessage.target.toLowerCase() + \" threw error '\" + e + \"'.\");\n      }\n\n      if (invocationMessage.invocationId) {\n        // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\n        var message = \"Server requested a response, which is not supported in this version of the client.\";\n        this.logger.log(LogLevel.Error, message); // We don't want to wait on the stop itself.\n\n        this.stopPromise = this.stopInternal(new Error(message));\n      }\n    } else {\n      this.logger.log(LogLevel.Warning, \"No client method with the name '\" + invocationMessage.target + \"' found.\");\n    }\n  };\n\n  HubConnection.prototype.connectionClosed = function (error) {\n    this.logger.log(LogLevel.Debug, \"HubConnection.connectionClosed(\" + error + \") called while in state \" + this.connectionState + \".\"); // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\n\n    this.stopDuringStartError = this.stopDuringStartError || error || new Error(\"The underlying connection was closed before the hub handshake could complete.\"); // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\n    // If it has already completed, this should just noop.\n\n    if (this.handshakeResolver) {\n      this.handshakeResolver();\n    }\n\n    this.cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\n    this.cleanupTimeout();\n    this.cleanupPingTimer();\n\n    if (this.connectionState === HubConnectionState.Disconnecting) {\n      this.completeClose(error);\n    } else if (this.connectionState === HubConnectionState.Connected && this.reconnectPolicy) {\n      // tslint:disable-next-line:no-floating-promises\n      this.reconnect(error);\n    } else if (this.connectionState === HubConnectionState.Connected) {\n      this.completeClose(error);\n    } // If none of the above if conditions were true were called the HubConnection must be in either:\n    // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\n    // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\n    //    and potentially continue the reconnect() loop.\n    // 3. The Disconnected state in which case we're already done.\n\n  };\n\n  HubConnection.prototype.completeClose = function (error) {\n    var _this = this;\n\n    if (this.connectionStarted) {\n      this.connectionState = HubConnectionState.Disconnected;\n      this.connectionStarted = false;\n\n      try {\n        this.closedCallbacks.forEach(function (c) {\n          return c.apply(_this, [error]);\n        });\n      } catch (e) {\n        this.logger.log(LogLevel.Error, \"An onclose callback called with error '\" + error + \"' threw error '\" + e + \"'.\");\n      }\n    }\n  };\n\n  HubConnection.prototype.reconnect = function (error) {\n    return __awaiter(this, void 0, void 0, function () {\n      var reconnectStartTime, previousReconnectAttempts, retryError, nextRetryDelay, e_4;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            reconnectStartTime = Date.now();\n            previousReconnectAttempts = 0;\n            retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\n            nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\n\n            if (nextRetryDelay === null) {\n              this.logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\n              this.completeClose(error);\n              return [2\n              /*return*/\n              ];\n            }\n\n            this.connectionState = HubConnectionState.Reconnecting;\n\n            if (error) {\n              this.logger.log(LogLevel.Information, \"Connection reconnecting because of error '\" + error + \"'.\");\n            } else {\n              this.logger.log(LogLevel.Information, \"Connection reconnecting.\");\n            }\n\n            if (this.onreconnecting) {\n              try {\n                this.reconnectingCallbacks.forEach(function (c) {\n                  return c.apply(_this, [error]);\n                });\n              } catch (e) {\n                this.logger.log(LogLevel.Error, \"An onreconnecting callback called with error '\" + error + \"' threw error '\" + e + \"'.\");\n              } // Exit early if an onreconnecting callback called connection.stop().\n\n\n              if (this.connectionState !== HubConnectionState.Reconnecting) {\n                this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\n                return [2\n                /*return*/\n                ];\n              }\n            }\n\n            _a.label = 1;\n\n          case 1:\n            if (!(nextRetryDelay !== null)) return [3\n            /*break*/\n            , 7];\n            this.logger.log(LogLevel.Information, \"Reconnect attempt number \" + previousReconnectAttempts + \" will start in \" + nextRetryDelay + \" ms.\");\n            return [4\n            /*yield*/\n            , new Promise(function (resolve) {\n              _this.reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);\n            })];\n\n          case 2:\n            _a.sent();\n\n            this.reconnectDelayHandle = undefined;\n\n            if (this.connectionState !== HubConnectionState.Reconnecting) {\n              this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\n              return [2\n              /*return*/\n              ];\n            }\n\n            _a.label = 3;\n\n          case 3:\n            _a.trys.push([3, 5,, 6]);\n\n            return [4\n            /*yield*/\n            , this.startInternal()];\n\n          case 4:\n            _a.sent();\n\n            this.connectionState = HubConnectionState.Connected;\n            this.logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\n\n            if (this.onreconnected) {\n              try {\n                this.reconnectedCallbacks.forEach(function (c) {\n                  return c.apply(_this, [_this.connection.connectionId]);\n                });\n              } catch (e) {\n                this.logger.log(LogLevel.Error, \"An onreconnected callback called with connectionId '\" + this.connection.connectionId + \"; threw error '\" + e + \"'.\");\n              }\n            }\n\n            return [2\n            /*return*/\n            ];\n\n          case 5:\n            e_4 = _a.sent();\n            this.logger.log(LogLevel.Information, \"Reconnect attempt failed because of error '\" + e_4 + \"'.\");\n\n            if (this.connectionState !== HubConnectionState.Reconnecting) {\n              this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect attempt. Done reconnecting.\");\n              return [2\n              /*return*/\n              ];\n            }\n\n            retryError = e_4 instanceof Error ? e_4 : new Error(e_4.toString());\n            nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\n            return [3\n            /*break*/\n            , 6];\n\n          case 6:\n            return [3\n            /*break*/\n            , 1];\n\n          case 7:\n            this.logger.log(LogLevel.Information, \"Reconnect retries have been exhausted after \" + (Date.now() - reconnectStartTime) + \" ms and \" + previousReconnectAttempts + \" failed attempts. Connection disconnecting.\");\n            this.completeClose();\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HubConnection.prototype.getNextRetryDelay = function (previousRetryCount, elapsedMilliseconds, retryReason) {\n    try {\n      return this.reconnectPolicy.nextRetryDelayInMilliseconds({\n        elapsedMilliseconds: elapsedMilliseconds,\n        previousRetryCount: previousRetryCount,\n        retryReason: retryReason\n      });\n    } catch (e) {\n      this.logger.log(LogLevel.Error, \"IRetryPolicy.nextRetryDelayInMilliseconds(\" + previousRetryCount + \", \" + elapsedMilliseconds + \") threw error '\" + e + \"'.\");\n      return null;\n    }\n  };\n\n  HubConnection.prototype.cancelCallbacksWithError = function (error) {\n    var callbacks = this.callbacks;\n    this.callbacks = {};\n    Object.keys(callbacks).forEach(function (key) {\n      var callback = callbacks[key];\n      callback(null, error);\n    });\n  };\n\n  HubConnection.prototype.cleanupPingTimer = function () {\n    if (this.pingServerHandle) {\n      clearTimeout(this.pingServerHandle);\n    }\n  };\n\n  HubConnection.prototype.cleanupTimeout = function () {\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  };\n\n  HubConnection.prototype.createInvocation = function (methodName, args, nonblocking, streamIds) {\n    if (nonblocking) {\n      if (streamIds.length !== 0) {\n        return {\n          arguments: args,\n          streamIds: streamIds,\n          target: methodName,\n          type: MessageType.Invocation\n        };\n      } else {\n        return {\n          arguments: args,\n          target: methodName,\n          type: MessageType.Invocation\n        };\n      }\n    } else {\n      var invocationId = this.invocationId;\n      this.invocationId++;\n\n      if (streamIds.length !== 0) {\n        return {\n          arguments: args,\n          invocationId: invocationId.toString(),\n          streamIds: streamIds,\n          target: methodName,\n          type: MessageType.Invocation\n        };\n      } else {\n        return {\n          arguments: args,\n          invocationId: invocationId.toString(),\n          target: methodName,\n          type: MessageType.Invocation\n        };\n      }\n    }\n  };\n\n  HubConnection.prototype.launchStreams = function (streams, promiseQueue) {\n    var _this = this;\n\n    if (streams.length === 0) {\n      return;\n    } // Synchronize stream data so they arrive in-order on the server\n\n\n    if (!promiseQueue) {\n      promiseQueue = Promise.resolve();\n    }\n\n    var _loop_1 = function (streamId) {\n      streams[streamId].subscribe({\n        complete: function () {\n          promiseQueue = promiseQueue.then(function () {\n            return _this.sendWithProtocol(_this.createCompletionMessage(streamId));\n          });\n        },\n        error: function (err) {\n          var message;\n\n          if (err instanceof Error) {\n            message = err.message;\n          } else if (err && err.toString) {\n            message = err.toString();\n          } else {\n            message = \"Unknown error\";\n          }\n\n          promiseQueue = promiseQueue.then(function () {\n            return _this.sendWithProtocol(_this.createCompletionMessage(streamId, message));\n          });\n        },\n        next: function (item) {\n          promiseQueue = promiseQueue.then(function () {\n            return _this.sendWithProtocol(_this.createStreamItemMessage(streamId, item));\n          });\n        }\n      });\n    }; // We want to iterate over the keys, since the keys are the stream ids\n    // tslint:disable-next-line:forin\n\n\n    for (var streamId in streams) {\n      _loop_1(streamId);\n    }\n  };\n\n  HubConnection.prototype.replaceStreamingParams = function (args) {\n    var streams = [];\n    var streamIds = [];\n\n    for (var i = 0; i < args.length; i++) {\n      var argument = args[i];\n\n      if (this.isObservable(argument)) {\n        var streamId = this.invocationId;\n        this.invocationId++; // Store the stream for later use\n\n        streams[streamId] = argument;\n        streamIds.push(streamId.toString()); // remove stream from args\n\n        args.splice(i, 1);\n      }\n    }\n\n    return [streams, streamIds];\n  };\n\n  HubConnection.prototype.isObservable = function (arg) {\n    // This allows other stream implementations to just work (like rxjs)\n    return arg && arg.subscribe && typeof arg.subscribe === \"function\";\n  };\n\n  HubConnection.prototype.createStreamInvocation = function (methodName, args, streamIds) {\n    var invocationId = this.invocationId;\n    this.invocationId++;\n\n    if (streamIds.length !== 0) {\n      return {\n        arguments: args,\n        invocationId: invocationId.toString(),\n        streamIds: streamIds,\n        target: methodName,\n        type: MessageType.StreamInvocation\n      };\n    } else {\n      return {\n        arguments: args,\n        invocationId: invocationId.toString(),\n        target: methodName,\n        type: MessageType.StreamInvocation\n      };\n    }\n  };\n\n  HubConnection.prototype.createCancelInvocation = function (id) {\n    return {\n      invocationId: id,\n      type: MessageType.CancelInvocation\n    };\n  };\n\n  HubConnection.prototype.createStreamItemMessage = function (id, item) {\n    return {\n      invocationId: id,\n      item: item,\n      type: MessageType.StreamItem\n    };\n  };\n\n  HubConnection.prototype.createCompletionMessage = function (id, error, result) {\n    if (error) {\n      return {\n        error: error,\n        invocationId: id,\n        type: MessageType.Completion\n      };\n    }\n\n    return {\n      invocationId: id,\n      result: result,\n      type: MessageType.Completion\n    };\n  };\n\n  return HubConnection;\n}();\n\nexport { HubConnection }; //# sourceMappingURL=HubConnection.js.map","map":null,"metadata":{},"sourceType":"module"}